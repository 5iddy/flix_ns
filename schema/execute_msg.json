{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ExecuteMsg",
  "description": "ExecuteMsg is the main JSON serializable enum. Based on its variant, [`execute`](fn.execute.html) will handle the execution. Its variants are the main entry to various end points.",
  "oneOf": [
    {
      "description": "Register a name for a wallet\n\n**Example**:\n\n```json { \"register\": { \"name\": \"alice\" } } ```",
      "type": "object",
      "required": [
        "register"
      ],
      "properties": {
        "register": {
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "Name to be registered. This name resolves to its owners address. Name can only contain alphabets, digits and an underscore. Before the name is register, \".flix\" suffix is stripped if it is present, and it is convereted to lower case.",
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Transfer the ownership to a different wallet\n\n**Example**:\n\n```json { \"transfer_name\": { \"name\": \"alice\", \"to\": \"juno12......we34ex\" } } ```",
      "type": "object",
      "required": [
        "transfer_name"
      ],
      "properties": {
        "transfer_name": {
          "type": "object",
          "required": [
            "name",
            "to"
          ],
          "properties": {
            "name": {
              "description": "A name that is owned by the message sender that needs to be transfered.",
              "type": "string"
            },
            "to": {
              "description": "The address of the new owner to whom the aforementioned name is being transfered to.",
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Send tokens to aa wallet based on their name\n\n**Example**:\n\n```json { \"send_tokens\": { \"name\": \"alice\", \"amount\": [ { \"amount\": \"1000\", \"denom\": \"ujunox\" } ] } } ```",
      "type": "object",
      "required": [
        "send_tokens"
      ],
      "properties": {
        "send_tokens": {
          "type": "object",
          "required": [
            "amount",
            "name"
          ],
          "properties": {
            "amount": {
              "description": "The amount that the message sender wants to send to the owner of the name. The same amount (or more) mentioned here must also be sent to the contract.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/Coin"
              }
            },
            "name": {
              "description": "The owner of this name who will receive these tokens.",
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    {
      "description": "For deleting an NFT or name. The record will be deleted and thus will be available for registration.\n\n**Example**:\n\n```json { \"burn\": { \"name\": \"alice\" } } ```",
      "type": "object",
      "required": [
        "burn"
      ],
      "properties": {
        "burn": {
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "Name that needs to be burned or deleted.",
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    {
      "description": "A name owner can temporarily or permanantly give permission to spend or transfer a Name NFT to anyone. Approvals are required if the account user wanted to put it up for sale on the market. Marketplace Smart Contracts need to seek approval from the account user to permit/allow the transfer permission. They need execute this message with spender as the contract address, on the name request until an expiration. After the approval is expired, the spender won't be able to transfer or spend a Name NFT.\n\n**Example**:\n\n```json { \"approve\": { \"spender\": \"cosmwasm12...wer23uwei3\", \"name\": \"alice\", \"expires\": { \"at_height\": <block-height-u64>, // or \"at_time\": <unix-timestamp>, // or \"never\": {} } } } ```",
      "type": "object",
      "required": [
        "approve"
      ],
      "properties": {
        "approve": {
          "type": "object",
          "required": [
            "name",
            "spender"
          ],
          "properties": {
            "expires": {
              "description": "until",
              "anyOf": [
                {
                  "$ref": "#/definitions/Expiration"
                },
                {
                  "type": "null"
                }
              ]
            },
            "name": {
              "description": "the name",
              "type": "string"
            },
            "spender": {
              "description": "Spender's wallet address (or contract address) who needs to gain transfer or spend permission on",
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Remove previously granted Approval\n\n**Example**:\n\n```json { \"revoke\": { \"name\": \"alice\", \"spender\": \"cosmwasm12....2wer34s\" } } ```",
      "type": "object",
      "required": [
        "revoke"
      ],
      "properties": {
        "revoke": {
          "type": "object",
          "required": [
            "name",
            "spender"
          ],
          "properties": {
            "name": {
              "description": "the name of the NFT on which the the spender until now posses the approval or permission to spend or transfer NFT.",
              "type": "string"
            },
            "spender": {
              "description": "The spender's wallet address or contract address",
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    {
      "description": "The Config's `sale_flag` needs to be true, if the accounts are permitted to register. If `sale_flag` is false, then Registrations are met with a ClosedSaleWindow Error. By default, if no sale_flag is mentioned in the Initialise message, it will be set to true.\n\nThis variant is used by admin to set the sale_flag. Only the Contract Admin can call this end point and successfully change the flag.\n\n**Example**:\n\n```json { \"set_sale\": { \"flag\": true } } ```",
      "type": "object",
      "required": [
        "set_sale"
      ],
      "properties": {
        "set_sale": {
          "type": "object",
          "required": [
            "flag"
          ],
          "properties": {
            "flag": {
              "description": "Config's `sale_flag` will be set to whatever this value is.",
              "type": "boolean"
            }
          }
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Only admin can call this endpoint. He can only do it once. After the admin is changed, the current admin will lose his powers over the contract. Unless he recalls this endpoint and return it to its owner.\n\n**Example**:\n\n```json { \"change_admin\" : { \"admin\": \"cosmwasm12....2qwe23\" } } ```",
      "type": "object",
      "required": [
        "change_admin"
      ],
      "properties": {
        "change_admin": {
          "type": "object",
          "required": [
            "admin"
          ],
          "properties": {
            "admin": {
              "description": "the wallet address of the new admin",
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    }
  ],
  "definitions": {
    "Coin": {
      "type": "object",
      "required": [
        "amount",
        "denom"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "denom": {
          "type": "string"
        }
      }
    },
    "Expiration": {
      "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
      "oneOf": [
        {
          "description": "AtHeight will expire when `env.block.height` >= height",
          "type": "object",
          "required": [
            "at_height"
          ],
          "properties": {
            "at_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        {
          "description": "AtTime will expire when `env.block.time` >= time",
          "type": "object",
          "required": [
            "at_time"
          ],
          "properties": {
            "at_time": {
              "$ref": "#/definitions/Timestamp"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Never will never expire. Used to express the empty variant",
          "type": "object",
          "required": [
            "never"
          ],
          "properties": {
            "never": {
              "type": "object"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Timestamp": {
      "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
      "allOf": [
        {
          "$ref": "#/definitions/Uint64"
        }
      ]
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "Uint64": {
      "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
      "type": "string"
    }
  }
}
